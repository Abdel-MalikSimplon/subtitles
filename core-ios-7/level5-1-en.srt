1
00:00:02,009 --> 00:00:02,990
Welcome back.

2
00:00:02,990 --> 00:00:05,050
In this level, we'll be talking
about a new framework

3
00:00:05,050 --> 00:00:09,470
that's been added to iOS 7
called UIKit Dynamics.

4
00:00:09,470 --> 00:00:12,350
UIKit dynamics allows you to
add real-world physical

5
00:00:12,350 --> 00:00:14,490
behavior to your views.

6
00:00:14,490 --> 00:00:17,820
Things like springing a
notification view into place,

7
00:00:17,820 --> 00:00:19,980
or transitioning view
controllers and adding a

8
00:00:19,980 --> 00:00:23,280
little bit of bounciness to
the end of the transition.

9
00:00:23,280 --> 00:00:26,210
Even things like making views
look like they're swinging in

10
00:00:26,210 --> 00:00:30,720
on an invisible string is
possible with UIKit dynamics.

11
00:00:30,720 --> 00:00:33,860
And the underlying principle
behind using UIKit dynamics is

12
00:00:33,860 --> 00:00:37,100
that you define a set of
behaviors that decide how to

13
00:00:37,100 --> 00:00:40,660
animate views, as opposed to
applying the animations

14
00:00:40,660 --> 00:00:41,910
directly yourself.

15
00:00:44,310 --> 00:00:47,480
Anytime you want to use UIKit
Dynamics, you first have to

16
00:00:47,480 --> 00:00:52,310
declare a strong property of
type UIDynamicAnimator.

17
00:00:52,310 --> 00:00:54,600
This is really important,
because if it's not a strong

18
00:00:54,600 --> 00:00:57,600
property, none of the animations
will work.

19
00:00:57,600 --> 00:01:00,650
Next, somewhere after your
view has loaded, like in

20
00:01:00,650 --> 00:01:03,590
viewDidLoad, you need to
initialize that dynamic

21
00:01:03,590 --> 00:01:05,820
animator and give it
a reference view.

22
00:01:05,820 --> 00:01:08,770
Now, the reference view is
usually a container view,

23
00:01:08,770 --> 00:01:10,590
while the subviews are the
things that you're are

24
00:01:10,590 --> 00:01:12,330
actually animating.

25
00:01:12,330 --> 00:01:15,580
So here, we'll use self.view,
since it's a container of all

26
00:01:15,580 --> 00:01:17,180
of our subviews.

27
00:01:17,180 --> 00:01:20,640
Finally, once that animator is
set up, all you have to do is

28
00:01:20,640 --> 00:01:22,930
add behaviors to it, and
the animations will

29
00:01:22,930 --> 00:01:25,290
automatically start.

30
00:01:25,290 --> 00:01:26,820
So let's look at a few
of those behaviors.

31
00:01:29,870 --> 00:01:33,840
The first, UIGravityBehavior,
simulates how gravity would

32
00:01:33,840 --> 00:01:34,890
work on Earth.

33
00:01:34,890 --> 00:01:37,920
If you drop your keys, they'll
hit the ground.

34
00:01:37,920 --> 00:01:41,990
Well, if you add gravity to a
view, then that view will drop

35
00:01:41,990 --> 00:01:44,010
as soon as the behavior
is added.

36
00:01:44,010 --> 00:01:47,130
That's usually paired with a
UICollisionBehavior, which

37
00:01:47,130 --> 00:01:50,560
will set boundaries on how
far that drop can happen.

38
00:01:50,560 --> 00:01:53,200
So here you can see that the
purple square starts dropping,

39
00:01:53,200 --> 00:01:57,320
and when it reaches the bottom
edge of self.view, it bounces

40
00:01:57,320 --> 00:02:01,280
and stops, because there's a
collision behavior there.

41
00:02:01,280 --> 00:02:04,780
The UIPushBehavior allows you
to give a view a little push

42
00:02:04,780 --> 00:02:07,440
in any direction with a certain
velocity, so you can

43
00:02:07,440 --> 00:02:12,200
use that to move views in and
out in a straight line.

44
00:02:12,200 --> 00:02:16,050
A UISnapBehavior allows you to
take a view from one point and

45
00:02:16,050 --> 00:02:18,830
move it to another, and
add some effects, like

46
00:02:18,830 --> 00:02:23,040
springiness, to the view when
it comes into place.

47
00:02:23,040 --> 00:02:26,160
A UIAttachmentBehavior allows
you to link one view to

48
00:02:26,160 --> 00:02:29,010
another, so that when one view
moves, the other moves with

49
00:02:29,010 --> 00:02:32,540
it. Or you can even link it up
to an arbitrary point, like

50
00:02:32,540 --> 00:02:36,050
the point generated by a gesture
recognizer, and then

51
00:02:36,050 --> 00:02:38,320
use that to move views
around the screen in

52
00:02:38,320 --> 00:02:41,060
response to the finger.

53
00:02:41,060 --> 00:02:43,580
And finally, there's a generic
behavior class, called

54
00:02:43,580 --> 00:02:48,080
UIDynamicItemBehavior, that
controls things like density,

55
00:02:48,080 --> 00:02:51,960
linear and angular velocity,
elasticity.

56
00:02:51,960 --> 00:02:54,910
So, for example, you can see
that there's a gravity and

57
00:02:54,910 --> 00:02:58,100
collision behavior on the
square with a different

58
00:02:58,100 --> 00:03:00,830
elasticity and angular velocity
that causes it to

59
00:03:00,830 --> 00:03:03,940
turn a little bit as it falls,
and bounce a little bit more

60
00:03:03,940 --> 00:03:05,430
when hits that collision
boundary.

61
00:03:08,230 --> 00:03:10,140
So let's jump back
into the code.

62
00:03:10,140 --> 00:03:13,400
We want to try to create that
gravity simulation where the

63
00:03:13,400 --> 00:03:16,280
square starts in the middle of
the screen, and then falls

64
00:03:16,280 --> 00:03:18,150
down, but then bounces
when it hits the

65
00:03:18,150 --> 00:03:20,580
bottom edge of the view.

66
00:03:20,580 --> 00:03:24,410
So to start, we'll add a
UIGravityBehavior, and we'll

67
00:03:24,410 --> 00:03:27,760
use the initWithItems
initializer, passing in the

68
00:03:27,760 --> 00:03:31,050
item that we want to have
the behavior on.

69
00:03:31,050 --> 00:03:35,330
Here we want our purple square
box view to have this gravity

70
00:03:35,330 --> 00:03:40,100
attached to it, so we
initWithItems self.boxView.

71
00:03:40,100 --> 00:03:43,960
Then we add our behavior to the
animator and the gravity

72
00:03:43,960 --> 00:03:45,670
will begin.

73
00:03:45,670 --> 00:03:49,440
In this case, self.view is
the reference view, and

74
00:03:49,440 --> 00:03:53,055
self.boxView is this item that
we're going to have animate.

75
00:03:56,890 --> 00:03:59,700
Next, we need to set the gravity
direction, and that's

76
00:03:59,700 --> 00:04:02,750
set by using a CG vector, which
we can create with the

77
00:04:02,750 --> 00:04:05,320
CGVectorMake function.

78
00:04:05,320 --> 00:04:07,850
Now, the first number that
you pass to CGVectorMake

79
00:04:07,850 --> 00:04:11,670
determines the x direction of
the gravity, and the second

80
00:04:11,670 --> 00:04:13,960
number determines the y
direction of the gravity.

81
00:04:13,960 --> 00:04:16,380
Let's look at that in a little
bit more detail so we can

82
00:04:16,380 --> 00:04:17,760
understand what those
numbers mean.

83
00:04:20,839 --> 00:04:25,170
If we have a CG vector using the
numbers 0 and 1, then that

84
00:04:25,170 --> 00:04:27,940
means there's going to be no
gravity in the x direction, or

85
00:04:27,940 --> 00:04:31,010
horizontal direction, but there
will be some gravity in

86
00:04:31,010 --> 00:04:32,690
the y direction.

87
00:04:32,690 --> 00:04:36,050
So as you can see, the box will
fall straight down with a

88
00:04:36,050 --> 00:04:38,190
y vector of 1.

89
00:04:38,190 --> 00:04:42,080
If we increase that y direction
vector to 3, then it

90
00:04:42,080 --> 00:04:44,900
falls three times the rate
of speed that it did when

91
00:04:44,900 --> 00:04:46,460
it was set to 1.

92
00:04:46,460 --> 00:04:49,130
So we're really determining the
magnitude of how fast the

93
00:04:49,130 --> 00:04:50,380
view falls.

94
00:04:52,890 --> 00:04:56,200
If we want the gravity to pull
up instead of down, all we

95
00:04:56,200 --> 00:05:00,680
need to do is set the y vector
to a negative number.

96
00:05:00,680 --> 00:05:02,810
Here we're setting it to
negative 1, and that's going

97
00:05:02,810 --> 00:05:05,000
to cause that box to be
pulled towards the

98
00:05:05,000 --> 00:05:06,510
top and not the bottom.

99
00:05:09,360 --> 00:05:13,550
To move the box to the left or
the right, we can set the x

100
00:05:13,550 --> 00:05:15,900
vector and not the y vector.

101
00:05:15,900 --> 00:05:18,980
So here we're seeing that it's
being moved to the right at a

102
00:05:18,980 --> 00:05:20,230
magnitude of 1.

103
00:05:24,230 --> 00:05:27,050
As you might imagine, to move
to the left, we just need to

104
00:05:27,050 --> 00:05:29,690
apply a negative x vector.

105
00:05:29,690 --> 00:05:31,960
And here you can see the
difference between applying a

106
00:05:31,960 --> 00:05:35,850
magnitude of negative 1 and
a magnitude of negative 2.

107
00:05:35,850 --> 00:05:38,990
If you use negative 2, it moves
to the left faster than

108
00:05:38,990 --> 00:05:40,240
negative 1.

109
00:05:42,320 --> 00:05:43,650
So let's take a look
at what adding that

110
00:05:43,650 --> 00:05:45,110
gravity behavior did.

111
00:05:45,110 --> 00:05:47,630
It starts pulling the square
down, but it doesn't stop when

112
00:05:47,630 --> 00:05:50,130
it hits the edge of the
view, it keeps going.

113
00:05:50,130 --> 00:05:53,090
So for that reason, gravity is
usually paired with a UI

114
00:05:53,090 --> 00:05:56,040
collision behavior, so that we
can set boundaries on where

115
00:05:56,040 --> 00:05:59,070
that square can go.

116
00:05:59,070 --> 00:06:01,950
To help visualize the problem,
you can see that before the

117
00:06:01,950 --> 00:06:05,550
gravity is applied, we have our
boxView, and then as the

118
00:06:05,550 --> 00:06:08,580
gravity starts being applied,
it's pulled down.

119
00:06:08,580 --> 00:06:11,310
As motion starts and continues,
the box is pulled

120
00:06:11,310 --> 00:06:13,780
down a little bit farther, but
because there's no collision

121
00:06:13,780 --> 00:06:16,825
boundary, the box moves off
the edge of the screen and

122
00:06:16,825 --> 00:06:18,110
then keeps falling forever.

123
00:06:21,350 --> 00:06:23,990
So to fix this, we'll add a
collision boundary in addition

124
00:06:23,990 --> 00:06:26,520
to our gravity behavior.

125
00:06:26,520 --> 00:06:30,390
If the subview that has the
gravity applied never needs to

126
00:06:30,390 --> 00:06:33,662
leave its container view, we can
use the translatesRefere

127
00:06:33,662 --> 00:06:38,540
nceBoundsIntoBoundary property
and set it to yes, and that's

128
00:06:38,540 --> 00:06:41,750
going to create boundaries for
each of those four walls that

129
00:06:41,750 --> 00:06:43,000
the view encompasses.

130
00:06:45,610 --> 00:06:49,990
Now, as the box moves down,
the edge of self.view is

131
00:06:49,990 --> 00:06:52,920
actually acting as a collision
boundary, and the gravity's

132
00:06:52,920 --> 00:06:55,390
still there, but the boundary
prevents the boxView from

133
00:06:55,390 --> 00:06:57,295
moving any further than the
edge of the screen.

134
00:07:00,780 --> 00:07:03,180
So now it's your turn to have
some fun playing with UIKit

135
00:07:03,180 --> 00:07:04,430
Dynamics in the challenges.

